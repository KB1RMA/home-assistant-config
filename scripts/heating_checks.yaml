# Heating System Health Checks
#
# This script monitors a heating zone to ensure it is actually heating up when calling for heat.
# It is designed to detect failures like a stuck valve, failed pump, or air lock.
#
# Logic Flow:
# 1. Triggered when a zone calls for heat (via automation).
# 2. Captures the starting temperature of the zone's outlet.
# 3. Waits for 5 minutes to allow the system to heat up.
# 4. Verifies the zone is STILL calling for heat (and has been continuously).
# 5. Checks if the temperature has risen by at least 5°F.
# 6. If temp hasn't risen (and isn't already hot), sends an alert.

check_heating_zone_health:
  alias: "Check Heating Zone Health"
  description: "Monitors a heating zone for failure to heat up"
  mode: parallel
  fields:
    zone_name:
      description: "Name of the zone"
      example: "Zone 6"
    call_for_heat_entity:
      description: "Binary sensor entity ID"
      example: "binary_sensor.boiler_zone_6_call_for_heat"
    temperature_entity:
      description: "Temperature sensor entity ID"
      example: "sensor.heating_zone_6_outlet"
    boiler_entity:
      description: "Boiler outlet temperature sensor"
      default: "sensor.shelly_furnace_monitor_boiler_outlet"
      example: "sensor.shelly_furnace_monitor_boiler_outlet"
    max_temp_diff:
      description: "Maximum allowed difference between boiler and zone temperature"
      default: 25
      example: 25
  sequence:
    # Capture start temp and set defaults
    - variables:
        start_temp: "{{ states(temperature_entity) | float(0) }}"
        boiler_sensor: "{{ boiler_entity | default('sensor.shelly_furnace_monitor_boiler_outlet') }}"
        allowed_diff: "{{ max_temp_diff | default(25) | float }}"
    
    # Wait 5 minutes
    - delay:
        minutes: 5
        
    # Check if still calling for heat AND has been for at least 4 minutes (240 seconds)
    # This prevents false alarms if the zone turned off and back on during the wait
    - condition: template
      value_template: >
        {{ is_state(call_for_heat_entity, 'on') and 
           (now() - states[call_for_heat_entity].last_changed).total_seconds() > 240 }}
           
    # Check for failure:
    # 1. Temperature failed to rise by 5°F (and is not already hot)
    # 2. OR Large difference between Boiler Outlet and Zone Outlet (indicating flow issue)
    - condition: template
      value_template: >
        {% set current_temp = states(temperature_entity) | float(0) %}
        {% set boiler_temp = states(boiler_sensor) | float(0) %}
        {% set temp_diff = boiler_temp - current_temp %}
        
        {# Fail if no rise #}
        {% set no_rise = (current_temp - start_temp < 5) and (current_temp < 130) %}
        
        {# Fail if boiler is hot but zone is cold (large delta) #}
        {% set large_delta = (boiler_temp > 140) and (temp_diff > allowed_diff) %}
        
        {{ no_rise or large_delta }}
        
    # Notify Dashboard
    - action: notify.persistent_notification
      data:
        title: "Heating Alert: {{ zone_name }}"
        message: >
          ⚠️ **Heating Failure Detected**
          
          {{ zone_name }} has been calling for heat for 5 minutes.
          
          **Status:**
          - Zone Temp: {{ states(temperature_entity) }}°F (Start: {{ start_temp }}°F)
          - Boiler Temp: {{ states(boiler_sensor) }}°F
          - Difference: {{ (states(boiler_sensor)|float(0) - states(temperature_entity)|float(0))|round(1) }}°F
          
    # Notify Mobile Devices
    - action: notify.notify
      data:
        title: "Heating Alert: {{ zone_name }}"
        message: "{{ zone_name }} failure! Zone: {{ states(temperature_entity) }}°F | Boiler: {{ states(boiler_sensor) }}°F"
